#include "user_funcs.h"
#include "os_tasks.h"

#define NO_TASK -1

// add self to the list of tasks with read permission
int OpenR(_queue_id stream_no) {
	if (_mutex_lock(&read_mutex) != MQX_OK) {
		printf("read lock failed\n");
		return HANDLER_QUEUE;
	}

	// give read permission to task

	_mutex_unlock(&read_mutex);
	return 0;
}

int _getline(char* string) {
	return 0;
}

// try to grab write permission for the task with id task_id (pass own id in here)
// if can't gain permission, then exit
// write mutex acts as write permissions
// since only one task can access
_queue_id OpenW() {
	printf("trying to lock write mutex\n");
	_mqx_uint result = _mutex_lock(&write_mutex);
	printf("write lock result: %u\n", result);
	if (result != MQX_EOK) {
		if (task_write_permission != NO_TASK) { // something is holding the write permission. return 0 (error)
			printf("write permission already held by task %i\n", task_write_permission);
			return 0;
		}

		task_write_permission = _task_get_id();

		_mutex_unlock(&write_mutex);

		return HANDLER_QUEUE; // if lock succeeds (no task is using write channel then return handler queue id
	}

	printf("error obtaining write lock for task %i\n", _task_get_id());
	return 0; // lock could not be obtained. return 0
}

int _putline(_queue_id qid, char* string) {
	return 0;
}

int Close() {\
	_task_id task_id = _task_get_id();

	// release the write channel
	if (_mutex_lock(&write_mutex) == MQX_EOK) {
		if (task_write_permission != task_id) { // something ELSE is holding the write permission.
			printf("write permission held by other task %i\n", task_write_permission);
			return 0; // FALSE
		}

		task_write_permission = NO_TASK;

		_mutex_unlock(&write_mutex);

		// release read channel permission
		// ...

		return 1; // TRUE
		}

	return 0;
}
